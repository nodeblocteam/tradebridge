{
  "version": 3,
  "sources": ["../../node_modules/viem/utils/signature/recoverPublicKey.ts", "../../node_modules/viem/accounts/utils/publicKeyToAddress.ts", "../../node_modules/viem/utils/signature/recoverAddress.ts", "../../node_modules/viem/utils/encoding/toRlp.ts", "../../node_modules/viem/utils/chain/assertCurrentChain.ts", "../../node_modules/viem/errors/fee.ts", "../../node_modules/viem/errors/block.ts", "../../node_modules/viem/utils/formatters/transaction.ts", "../../node_modules/viem/utils/formatters/block.ts", "../../node_modules/viem/errors/estimateGas.ts", "../../node_modules/viem/utils/blob/blobsToCommitments.ts", "../../node_modules/viem/utils/blob/blobsToProofs.ts", "../../node_modules/viem/utils/hash/sha256.ts", "../../node_modules/viem/utils/blob/commitmentToVersionedHash.ts", "../../node_modules/viem/utils/blob/commitmentsToVersionedHashes.ts", "../../node_modules/viem/constants/blob.ts", "../../node_modules/viem/constants/kzg.ts", "../../node_modules/viem/errors/blob.ts", "../../node_modules/viem/utils/blob/toBlobs.ts", "../../node_modules/viem/utils/blob/toBlobSidecars.ts", "../../node_modules/viem/utils/transaction/getTransactionType.ts", "../../node_modules/viem/utils/formatters/log.ts", "../../node_modules/viem/utils/formatters/transactionReceipt.ts", "../../node_modules/viem/utils/chain/defineChain.ts", "../../node_modules/viem/utils/transaction/assertTransaction.ts", "../../node_modules/viem/utils/transaction/serializeAccessList.ts", "../../node_modules/viem/experimental/eip7702/utils/serializeAuthorizationList.ts", "../../node_modules/viem/utils/transaction/serializeTransaction.ts", "../../node_modules/viem/utils/getAction.ts", "../../node_modules/viem/actions/public/getChainId.ts", "../../node_modules/viem/actions/public/getBlock.ts", "../../node_modules/viem/actions/public/getGasPrice.ts", "../../node_modules/viem/actions/public/estimateMaxPriorityFeePerGas.ts", "../../node_modules/viem/actions/public/estimateFeesPerGas.ts", "../../node_modules/viem/utils/errors/getEstimateGasError.ts", "../../node_modules/viem/actions/public/getBalance.ts", "../../node_modules/viem/experimental/eip7702/utils/hashAuthorization.ts", "../../node_modules/viem/experimental/eip7702/utils/recoverAuthorizationAddress.ts", "../../node_modules/viem/actions/public/getTransactionCount.ts", "../../node_modules/viem/actions/wallet/prepareTransactionRequest.ts", "../../node_modules/viem/actions/public/estimateGas.ts", "../../node_modules/viem/errors/account.ts"],
  "sourcesContent": ["import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport {\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const { r, s, v, yParity } = signature\n      const yParityOrV = Number(yParity ?? v)!\n      const recoveryBit = toRecoveryBit(yParityOrV)\n      return new secp256k1.Signature(\n        hexToBigInt(r),\n        hexToBigInt(s),\n      ).addRecoveryBit(recoveryBit)\n    }\n\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\n    const recoveryBit = toRecoveryBit(yParityOrV)\n    return secp256k1.Signature.fromCompact(\n      signatureHex.substring(2, 130),\n    ).addRecoveryBit(recoveryBit)\n  })()\n\n  const publicKey = signature_\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n\nfunction toRecoveryBit(yParityOrV: number) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\n  if (yParityOrV === 27) return 0\n  if (yParityOrV === 28) return 1\n  throw new Error('Invalid yParityOrV value')\n}\n", "import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\n\nexport type PublicKeyToAddressErrorType =\n  | ChecksumAddressErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey: Hex): Address {\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\n  return checksumAddress(`0x${address}`) as Address\n}\n", "import type { Address } from 'abitype'\n\nimport { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { recoverPublicKey } from './recoverPublicKey.js'\n\nexport type RecoverAddressParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverAddressReturnType = Address\n\nexport type RecoverAddressErrorType = ErrorType\n\nexport async function recoverAddress({\n  hash,\n  signature,\n}: RecoverAddressParameters): Promise<RecoverAddressReturnType> {\n  return publicKeyToAddress(await recoverPublicKey({ hash: hash, signature }))\n}\n", "import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n", "import {\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain | undefined\n  currentChainId: number\n}\n\nexport type AssertCurrentChainErrorType =\n  | ChainNotFoundErrorType\n  | ChainMismatchErrorType\n  | ErrorType\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n", "import { formatGwei } from '../utils/unit/formatGwei.js'\nimport { BaseError } from './base.js'\n\nexport type BaseFeeScalarErrorType = BaseFeeScalarError & {\n  name: 'BaseFeeScalarError'\n}\nexport class BaseFeeScalarError extends BaseError {\n  constructor() {\n    super('`baseFeeMultiplier` must be greater than 1.', {\n      name: 'BaseFeeScalarError',\n    })\n  }\n}\n\nexport type Eip1559FeesNotSupportedErrorType = Eip1559FeesNotSupportedError & {\n  name: 'Eip1559FeesNotSupportedError'\n}\nexport class Eip1559FeesNotSupportedError extends BaseError {\n  constructor() {\n    super('Chain does not support EIP-1559 fees.', {\n      name: 'Eip1559FeesNotSupportedError',\n    })\n  }\n}\n\nexport type MaxFeePerGasTooLowErrorType = MaxFeePerGasTooLowError & {\n  name: 'MaxFeePerGasTooLowError'\n}\nexport class MaxFeePerGasTooLowError extends BaseError {\n  constructor({ maxPriorityFeePerGas }: { maxPriorityFeePerGas: bigint }) {\n    super(\n      `\\`maxFeePerGas\\` cannot be less than the \\`maxPriorityFeePerGas\\` (${formatGwei(\n        maxPriorityFeePerGas,\n      )} gwei).`,\n      { name: 'MaxFeePerGasTooLowError' },\n    )\n  }\n}\n", "import type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlockNotFoundErrorType = BlockNotFoundError & {\n  name: 'BlockNotFoundError'\n}\nexport class BlockNotFoundError extends BaseError {\n  constructor({\n    blockHash,\n    blockNumber,\n  }: {\n    blockHash?: Hash | undefined\n    blockNumber?: bigint | undefined\n  }) {\n    let identifier = 'Block'\n    if (blockHash) identifier = `Block at hash \"${blockHash}\"`\n    if (blockNumber) identifier = `Block at number \"${blockNumber}\"`\n    super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' })\n  }\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { SignedAuthorizationList } from '../../experimental/eip7702/types/authorization.js'\nimport type { RpcAuthorizationList } from '../../experimental/eip7702/types/rpc.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransaction } from '../../types/rpc.js'\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\ntype TransactionPendingDependencies =\n  | 'blockHash'\n  | 'blockNumber'\n  | 'transactionIndex'\n\nexport type FormattedTransaction<\n  chain extends Chain | undefined = undefined,\n  blockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    chain,\n    'transaction',\n    Transaction\n  >,\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\n    ExtractChainFormatterExclude<chain, 'transaction'>,\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\n  [_K in _ExcludedPendingDependencies]: never\n} & Pick<\n    Transaction<bigint, number, blockTag extends 'pending' ? true : false>,\n    TransactionPendingDependencies\n  >\n\nexport const transactionType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const satisfies Record<Hex, TransactionType>\n\nexport type FormatTransactionErrorType = ErrorType\n\nexport function formatTransaction(transaction: ExactPartial<RpcTransaction>) {\n  const transaction_ = {\n    ...transaction,\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\n    blockNumber: transaction.blockNumber\n      ? BigInt(transaction.blockNumber)\n      : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\n      ? BigInt(transaction.maxFeePerBlobGas)\n      : undefined,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: transaction.transactionIndex\n      ? Number(transaction.transactionIndex)\n      : null,\n    type: transaction.type\n      ? (transactionType as any)[transaction.type]\n      : undefined,\n    typeHex: transaction.type ? transaction.type : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined,\n  } as Transaction\n\n  if (transaction.authorizationList)\n    transaction_.authorizationList = formatAuthorizationList(\n      transaction.authorizationList,\n    )\n\n  transaction_.yParity = (() => {\n    // If `yParity` is provided, we will use it.\n    if (transaction.yParity) return Number(transaction.yParity)\n\n    // If no `yParity` provided, try derive from `v`.\n    if (typeof transaction_.v === 'bigint') {\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\n    }\n\n    return undefined\n  })()\n\n  if (transaction_.type === 'legacy') {\n    delete transaction_.accessList\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n    delete transaction_.yParity\n  }\n  if (transaction_.type === 'eip2930') {\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n  }\n  if (transaction_.type === 'eip1559') {\n    delete transaction_.maxFeePerBlobGas\n  }\n  return transaction_\n}\n\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\n  'transaction',\n  formatTransaction,\n)\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction formatAuthorizationList(\n  authorizationList: RpcAuthorizationList,\n): SignedAuthorizationList {\n  return authorizationList.map(\n    (authorization) =>\n      ({\n        contractAddress: (authorization as any).address,\n        r: authorization.r,\n        s: authorization.s,\n        chainId: Number(authorization.chainId),\n        nonce: Number(authorization.nonce),\n        ...(typeof authorization.yParity !== 'undefined'\n          ? { yParity: Number(authorization.yParity) }\n          : {}),\n        ...(typeof authorization.v !== 'undefined' &&\n        typeof authorization.yParity === 'undefined'\n          ? { v: Number(authorization.v) }\n          : {}),\n      }) as any,\n  ) as SignedAuthorizationList\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\n\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\n\nexport type FormattedBlock<\n  chain extends Chain | undefined = undefined,\n  includeTransactions extends boolean = boolean,\n  blockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    chain,\n    'block',\n    Block<bigint, includeTransactions>\n  >,\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\n    ExtractChainFormatterExclude<chain, 'block'>,\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\n    [_key in _ExcludedPendingDependencies]: never\n  } & Pick<\n      Block<bigint, includeTransactions, blockTag>,\n      BlockPendingDependencies\n    >,\n  _Transactions = includeTransactions extends true\n    ? Prettify<FormattedTransaction<chain, blockTag>>[]\n    : Hash[],\n> = Omit<_Formatted, 'transactions'> & {\n  transactions: _Transactions\n}\n\nexport type FormatBlockErrorType = ErrorType\n\nexport function formatBlock(block: ExactPartial<RpcBlock>) {\n  const transactions = block.transactions?.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return formatTransaction(transaction)\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas\n      ? BigInt(block.excessBlobGas)\n      : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    hash: block.hash ? block.hash : null,\n    logsBloom: block.logsBloom ? block.logsBloom : null,\n    nonce: block.nonce ? block.nonce : null,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n  } as Block\n}\n\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\n", "import type { Account } from '../accounts/types.js'\nimport type { EstimateGasParameters } from '../actions/public/estimateGas.js'\nimport type { Chain } from '../types/chain.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\nimport { prettyPrint } from './transaction.js'\n\nexport type EstimateGasExecutionErrorType = EstimateGasExecutionError & {\n  name: 'EstimateGasExecutionError'\n}\nexport class EstimateGasExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<EstimateGasParameters<any>, 'account'> & {\n      account?: Account | undefined\n      chain?: Chain | undefined\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Estimate Gas Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'EstimateGasExecutionError',\n    })\n    this.cause = cause\n  }\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n", "import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\nexport const versionedHashVersionKzg = 1\n", "import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n      name: 'BlobSizeTooLargeError',\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  constructor() {\n    super('Blob data must not be empty.', { name: 'EmptyBlobError' })\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n      name: 'InvalidVersionedHashSizeError',\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n      name: 'InvalidVersionedHashVersionError',\n    })\n  }\n}\n", "import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n", "import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestEIP7702,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport type {\n  Assign,\n  ExactPartial,\n  IsNever,\n  OneOf,\n  ValueOf,\n} from '../../types/utils.js'\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends\n        | MatchKeys<TransactionSerializableLegacy, transaction>\n        | MatchKeys<TransactionRequestLegacy, transaction>\n        | LegacyProperties\n        ? 'legacy'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP1559, transaction>\n        | MatchKeys<TransactionRequestEIP1559, transaction>\n        | EIP1559Properties\n        ? 'eip1559'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP2930, transaction>\n        | MatchKeys<TransactionRequestEIP2930, transaction>\n        | EIP2930Properties\n        ? 'eip2930'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP4844, transaction>\n        | MatchKeys<TransactionRequestEIP4844, transaction>\n        | EIP4844Properties\n        ? 'eip4844'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP7702, transaction>\n        | MatchKeys<TransactionRequestEIP7702, transaction>\n        | EIP7702Properties\n        ? 'eip7702'\n        : never)\n    | (transaction['type'] extends TransactionSerializableGeneric['type']\n        ? Extract<transaction['type'], string>\n        : never),\n> = IsNever<keyof transaction> extends true\n  ? string\n  : IsNever<result> extends false\n    ? result\n    : string\n\nexport type GetTransactionTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (typeof transaction.authorizationList !== 'undefined')\n    return 'eip7702' as any\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype MatchKeys<T extends object, U extends object> = ValueOf<\n  Required<{\n    [K in keyof U]: K extends keyof T ? K : undefined\n  }>\n> extends string\n  ? T\n  : never\n\ntype BaseProperties = {\n  accessList?: undefined\n  authorizationList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesLegacy> & {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\ntype EIP7702Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP1559> & {\n    authorizationList: TransactionSerializableEIP7702['authorizationList']\n  }\n>\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  chain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  chain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n", "import type { Chain, ChainFormatters } from '../../types/chain.js'\nimport type { Assign, Prettify } from '../../types/utils.js'\n\nexport function defineChain<\n  formatters extends ChainFormatters,\n  const chain extends Chain<formatters>,\n>(chain: chain): Prettify<Assign<Chain<undefined>, chain>> {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain,\n  } as Assign<Chain<undefined>, chain>\n}\n", "import { versionedHashVersionKzg } from '../../constants/kzg.js'\nimport { maxUint256 } from '../../constants/number.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n  InvalidVersionedHashSizeError,\n  type InvalidVersionedHashSizeErrorType,\n  InvalidVersionedHashVersionError,\n  type InvalidVersionedHashVersionErrorType,\n} from '../../errors/blob.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nexport type AssertTransactionEIP7702ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | ErrorType\n\nexport function assertTransactionEIP7702(\n  transaction: TransactionSerializableEIP7702,\n) {\n  const { authorizationList } = transaction\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const { contractAddress, chainId } = authorization\n      if (!isAddress(contractAddress))\n        throw new InvalidAddressError({ address: contractAddress })\n      if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP4844ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | EmptyBlobErrorType\n  | InvalidVersionedHashSizeErrorType\n  | InvalidVersionedHashVersionErrorType\n  | ErrorType\n\nexport function assertTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n) {\n  const { blobVersionedHashes } = transaction\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\n    for (const hash of blobVersionedHashes) {\n      const size_ = size(hash)\n      const version = hexToNumber(slice(hash, 0, 1))\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\n      if (version !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxFeePerGas && maxFeePerGas > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n", "import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList | undefined,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport { toHex } from '../../../utils/encoding/toHex.js'\nimport { toYParitySignatureArray } from '../../../utils/transaction/serializeTransaction.js'\nimport type {\n  AuthorizationList,\n  SerializedAuthorizationList,\n} from '../types/authorization.js'\n\nexport type SerializeAuthorizationListReturnType = SerializedAuthorizationList\n\nexport type SerializeAuthorizationListErrorType = ErrorType\n\n/*\n * Serializes an EIP-7702 authorization list.\n */\nexport function serializeAuthorizationList(\n  authorizationList?: AuthorizationList<number, true> | undefined,\n): SerializeAuthorizationListReturnType {\n  if (!authorizationList || authorizationList.length === 0) return []\n\n  const serializedAuthorizationList = []\n  for (const authorization of authorizationList) {\n    const { contractAddress, chainId, nonce, ...signature } = authorization\n    serializedAuthorizationList.push([\n      toHex(chainId),\n      contractAddress,\n      nonce ? toHex(nonce) : '0x',\n      ...toYParitySignatureArray({}, signature),\n    ])\n  }\n\n  return serializedAuthorizationList as {} as SerializeAuthorizationListReturnType\n}\n", "import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  Signature,\n  SignatureLegacy,\n} from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from '../blob/blobsToCommitments.js'\nimport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n} from '../blob/blobsToProofs.js'\nimport {\n  type CommitmentsToVersionedHashesErrorType,\n  commitmentsToVersionedHashes,\n} from '../blob/commitmentsToVersionedHashes.js'\nimport {\n  type ToBlobSidecarsErrorType,\n  toBlobSidecars,\n} from '../blob/toBlobSidecars.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type SerializeAuthorizationListErrorType,\n  serializeAuthorizationList,\n} from '../../experimental/eip7702/utils/serializeAuthorizationList.js'\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionEIP7702ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionEIP7702,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransactionTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  transaction extends TransactionSerializable = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n> = TransactionSerialized<_transactionType>\n\nexport type SerializeTransactionFn<\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = never,\n> = typeof serializeTransaction<\n  OneOf<TransactionSerializable | transaction>,\n  _transactionType\n>\n\nexport type SerializeTransactionErrorType =\n  | GetTransactionTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionEIP4844ErrorType\n  | SerializeTransactionEIP7702ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  const transaction extends TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n>(\n  transaction: transaction,\n  signature?: Signature | undefined,\n): SerializedTransactionReturnType<transaction, _transactionType> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip4844')\n    return serializeTransactionEIP4844(\n      transaction as TransactionSerializableEIP4844,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip7702')\n    return serializeTransactionEIP7702(\n      transaction as TransactionSerializableEIP7702,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature as SignatureLegacy,\n  ) as SerializedTransactionReturnType<transaction>\n}\n\ntype SerializeTransactionEIP7702ErrorType =\n  | AssertTransactionEIP7702ErrorType\n  | SerializeAuthorizationListErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP7702(\n  transaction: TransactionSerializableEIP7702,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP7702 {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP7702(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n  const serializedAuthorizationList =\n    serializeAuthorizationList(authorizationList)\n\n  return concatHex([\n    '0x04',\n    toRlp([\n      toHex(chainId),\n      nonce ? toHex(nonce) : '0x',\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n      maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n      gas ? toHex(gas) : '0x',\n      to ?? '0x',\n      value ? toHex(value) : '0x',\n      data ?? '0x',\n      serializedAccessList,\n      serializedAuthorizationList,\n      ...toYParitySignatureArray(transaction, signature),\n    ]),\n  ]) as TransactionSerializedEIP7702\n}\n\ntype SerializeTransactionEIP4844ErrorType =\n  | AssertTransactionEIP4844ErrorType\n  | BlobsToCommitmentsErrorType\n  | CommitmentsToVersionedHashesErrorType\n  | blobsToProofsErrorType\n  | ToBlobSidecarsErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP4844 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP4844(transaction)\n\n  let blobVersionedHashes = transaction.blobVersionedHashes\n  let sidecars = transaction.sidecars\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (\n    transaction.blobs &&\n    (typeof blobVersionedHashes === 'undefined' ||\n      typeof sidecars === 'undefined')\n  ) {\n    const blobs = (\n      typeof transaction.blobs[0] === 'string'\n        ? transaction.blobs\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\n    ) as Hex[]\n    const kzg = transaction.kzg!\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg,\n    })\n\n    if (typeof blobVersionedHashes === 'undefined')\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments,\n      })\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\n    }\n  }\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature),\n  ] as const\n\n  const blobs: Hex[] = []\n  const commitments: Hex[] = []\n  const proofs: Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return concatHex([\n    '0x03',\n    sidecars\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\n        toRlp([serializedTransaction, blobs, commitments, proofs])\n      : // If sidecars are disabled, standard envelope is used:\n        toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP4844\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: SignatureLegacy | undefined,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    const r = trim(signature.r)\n    const s = trim(signature.s)\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      r === '0x00' ? '0x' : r,\n      s === '0x00' ? '0x' : s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\n}\n\nexport function toYParitySignatureArray(\n  transaction: TransactionSerializableGeneric,\n  signature_?: Signature | undefined,\n) {\n  const signature = signature_ ?? transaction\n  const { v, yParity } = signature\n\n  if (typeof signature.r === 'undefined') return []\n  if (typeof signature.s === 'undefined') return []\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\n\n  const r = trim(signature.r)\n  const s = trim(signature.s)\n\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\n    if (v === 0n) return '0x'\n    if (v === 1n) return toHex(1)\n\n    return v === 27n ? '0x' : toHex(1)\n  })()\n\n  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s]\n}\n", "import type { Client } from '../clients/createClient.js'\nimport type { PublicActions } from '../clients/decorators/public.js'\nimport type { WalletActions } from '../clients/decorators/wallet.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { Account } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { RpcSchema } from '../types/eip1193.js'\n\n/**\n * Retrieves and returns an action from the client (if exists), and falls\n * back to the tree-shakable action.\n *\n * Useful for extracting overridden actions from a client (ie. if a consumer\n * wants to override the `sendTransaction` implementation).\n */\nexport function getAction<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  rpcSchema extends RpcSchema | undefined,\n  extended extends { [key: string]: unknown },\n  client extends Client<transport, chain, account, rpcSchema, extended>,\n  parameters,\n  returnType,\n>(\n  client: client,\n  actionFn: (_: any, parameters: parameters) => returnType,\n  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,\n  // meaning that `actionFn.name` will not always work. For that case, the consumer\n  // needs to pass the name explicitly.\n  name: keyof PublicActions | keyof WalletActions | (string & {}),\n): (parameters: parameters) => returnType {\n  const action_implicit = client[actionFn.name]\n  if (typeof action_implicit === 'function')\n    return action_implicit as (params: parameters) => returnType\n\n  const action_explicit = client[name]\n  if (typeof action_explicit === 'function')\n    return action_explicit as (params: parameters) => returnType\n\n  return (params) => actionFn(client, params)\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToNumberErrorType,\n  hexToNumber,\n} from '../../utils/encoding/fromHex.js'\n\nexport type GetChainIdReturnType = number\n\nexport type GetChainIdErrorType =\n  | HexToNumberErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the chain ID associated with the current network.\n *\n * - Docs: https://viem.sh/docs/actions/public/getChainId\n * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n *\n * @param client - Client to use\n * @returns The current chain ID. {@link GetChainIdReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getChainId } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const chainId = await getChainId(client)\n * // 1\n */\nexport async function getChainId<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>): Promise<GetChainIdReturnType> {\n  const chainIdHex = await client.request(\n    {\n      method: 'eth_chainId',\n    },\n    { dedupe: true },\n  )\n  return hexToNumber(chainIdHex)\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  BlockNotFoundError,\n  type BlockNotFoundErrorType,\n} from '../../errors/block.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormattedBlock,\n  formatBlock,\n} from '../../utils/formatters/block.js'\n\nexport type GetBlockParameters<\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: includeTransactions | undefined\n} & (\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash | undefined\n      blockNumber?: undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      blockNumber?: undefined\n      /**\n       * The block tag.\n       * @default 'latest'\n       */\n      blockTag?: blockTag | BlockTag | undefined\n    }\n)\n\nexport type GetBlockReturnType<\n  chain extends Chain | undefined = undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = Prettify<FormattedBlock<chain, includeTransactions, blockTag>>\n\nexport type GetBlockErrorType =\n  | BlockNotFoundErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns information about a block at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlock\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockParameters}\n * @returns Information about the block. {@link GetBlockReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlock } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getBlock(client)\n */\nexport async function getBlock<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  client: Client<Transport, chain, account>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag: blockTag_,\n    includeTransactions: includeTransactions_,\n  }: GetBlockParameters<includeTransactions, blockTag> = {},\n): Promise<GetBlockReturnType<chain, includeTransactions, blockTag>> {\n  const blockTag = blockTag_ ?? 'latest'\n  const includeTransactions = includeTransactions_ ?? false\n\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let block: RpcBlock | null = null\n  if (blockHash) {\n    block = await client.request(\n      {\n        method: 'eth_getBlockByHash',\n        params: [blockHash, includeTransactions],\n      },\n      { dedupe: true },\n    )\n  } else {\n    block = await client.request(\n      {\n        method: 'eth_getBlockByNumber',\n        params: [blockNumberHex || blockTag, includeTransactions],\n      },\n      { dedupe: Boolean(blockNumberHex) },\n    )\n  }\n\n  if (!block) throw new BlockNotFoundError({ blockHash, blockNumber })\n\n  const format = client.chain?.formatters?.block?.format || formatBlock\n  return format(block)\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetGasPriceReturnType = bigint\n\nexport type GetGasPriceErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the current price of gas (in wei).\n *\n * - Docs: https://viem.sh/docs/actions/public/getGasPrice\n * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\n *\n * @param client - Client to use\n * @returns The gas price (in wei). {@link GetGasPriceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getGasPrice } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasPrice = await getGasPrice(client)\n */\nexport async function getGasPrice<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>): Promise<GetGasPriceReturnType> {\n  const gasPrice = await client.request({\n    method: 'eth_gasPrice',\n  })\n  return BigInt(gasPrice)\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  Eip1559FeesNotSupportedError,\n  type Eip1559FeesNotSupportedErrorType,\n} from '../../errors/fee.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type { Chain, ChainFeesFnParameters } from '../../types/chain.js'\nimport type { GetChainParameter } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToBigIntErrorType,\n  hexToBigInt,\n} from '../../utils/encoding/fromHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { PrepareTransactionRequestParameters } from '../wallet/prepareTransactionRequest.js'\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport { type GetGasPriceErrorType, getGasPrice } from './getGasPrice.js'\n\nexport type EstimateMaxPriorityFeePerGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = GetChainParameter<chain, chainOverride>\n\nexport type EstimateMaxPriorityFeePerGasReturnType = bigint\n\nexport type EstimateMaxPriorityFeePerGasErrorType =\n  | GetBlockErrorType\n  | HexToBigIntErrorType\n  | RequestErrorType\n  | GetBlockErrorType\n  | GetGasPriceErrorType\n  | Eip1559FeesNotSupportedErrorType\n  | ErrorType\n\n/**\n * Returns an estimate for the max priority fee per gas (in wei) for a\n * transaction to be likely included in the next block.\n * Defaults to [`chain.fees.defaultPriorityFee`](/docs/clients/chains#fees-defaultpriorityfee) if set.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas\n *\n * @param client - Client to use\n * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateMaxPriorityFeePerGas } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const maxPriorityFeePerGas = await estimateMaxPriorityFeePerGas(client)\n * // 10000000n\n */\nexport async function estimateMaxPriorityFeePerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  args?:\n    | EstimateMaxPriorityFeePerGasParameters<chain, chainOverride>\n    | undefined,\n): Promise<EstimateMaxPriorityFeePerGasReturnType> {\n  return internal_estimateMaxPriorityFeePerGas(client, args as any)\n}\n\nexport async function internal_estimateMaxPriorityFeePerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  args: EstimateMaxPriorityFeePerGasParameters<chain, chainOverride> & {\n    block?: Block | undefined\n    request?:\n      | PrepareTransactionRequestParameters<\n          chain,\n          Account | undefined,\n          chainOverride\n        >\n      | undefined\n  },\n): Promise<EstimateMaxPriorityFeePerGasReturnType> {\n  const { block: block_, chain = client.chain, request } = args || {}\n\n  try {\n    const maxPriorityFeePerGas =\n      chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee\n\n    if (typeof maxPriorityFeePerGas === 'function') {\n      const block =\n        block_ || (await getAction(client, getBlock, 'getBlock')({}))\n      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({\n        block,\n        client,\n        request,\n      } as ChainFeesFnParameters)\n      if (maxPriorityFeePerGas_ === null) throw new Error()\n      return maxPriorityFeePerGas_\n    }\n\n    if (typeof maxPriorityFeePerGas !== 'undefined') return maxPriorityFeePerGas\n\n    const maxPriorityFeePerGasHex = await client.request({\n      method: 'eth_maxPriorityFeePerGas',\n    })\n    return hexToBigInt(maxPriorityFeePerGasHex)\n  } catch {\n    // If the RPC Provider does not support `eth_maxPriorityFeePerGas`\n    // fall back to calculating it manually via `gasPrice - baseFeePerGas`.\n    // See: https://github.com/ethereum/pm/issues/328#:~:text=eth_maxPriorityFeePerGas%20after%20London%20will%20effectively%20return%20eth_gasPrice%20%2D%20baseFee\n    const [block, gasPrice] = await Promise.all([\n      block_\n        ? Promise.resolve(block_)\n        : getAction(client, getBlock, 'getBlock')({}),\n      getAction(client, getGasPrice, 'getGasPrice')({}),\n    ])\n\n    if (typeof block.baseFeePerGas !== 'bigint')\n      throw new Eip1559FeesNotSupportedError()\n\n    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas\n\n    if (maxPriorityFeePerGas < 0n) return 0n\n    return maxPriorityFeePerGas\n  }\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  BaseFeeScalarError,\n  type BaseFeeScalarErrorType,\n  Eip1559FeesNotSupportedError,\n  type Eip1559FeesNotSupportedErrorType,\n} from '../../errors/fee.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type {\n  Chain,\n  ChainEstimateFeesPerGasFnParameters,\n  ChainFeesFnParameters,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesLegacy,\n  FeeValuesType,\n} from '../../types/fee.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { PrepareTransactionRequestParameters } from '../wallet/prepareTransactionRequest.js'\nimport {\n  type EstimateMaxPriorityFeePerGasErrorType,\n  internal_estimateMaxPriorityFeePerGas,\n} from './estimateMaxPriorityFeePerGas.js'\nimport { getBlock } from './getBlock.js'\nimport { type GetGasPriceErrorType, getGasPrice } from './getGasPrice.js'\n\nexport type EstimateFeesPerGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  type extends FeeValuesType = FeeValuesType,\n> = {\n  /**\n   * The type of fee values to return.\n   *\n   * - `legacy`: Returns the legacy gas price.\n   * - `eip1559`: Returns the max fee per gas and max priority fee per gas.\n   *\n   * @default 'eip1559'\n   */\n  type?: type | FeeValuesType | undefined\n} & GetChainParameter<chain, chainOverride>\n\nexport type EstimateFeesPerGasReturnType<\n  type extends FeeValuesType = FeeValuesType,\n> =\n  | (type extends 'legacy' ? FeeValuesLegacy : never)\n  | (type extends 'eip1559' ? FeeValuesEIP1559 : never)\n\nexport type EstimateFeesPerGasErrorType =\n  | BaseFeeScalarErrorType\n  | EstimateMaxPriorityFeePerGasErrorType\n  | GetGasPriceErrorType\n  | Eip1559FeesNotSupportedErrorType\n  | ErrorType\n\n/**\n * Returns an estimate for the fees per gas (in wei) for a\n * transaction to be likely included in the next block.\n * Defaults to [`chain.fees.estimateFeesPerGas`](/docs/clients/chains#fees-estimatefeespergas) if set.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateFeesPerGasParameters}\n * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateFeesPerGas } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const maxPriorityFeePerGas = await estimateFeesPerGas(client)\n * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }\n */\nexport async function estimateFeesPerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n  type extends FeeValuesType = 'eip1559',\n>(\n  client: Client<Transport, chain>,\n  args?: EstimateFeesPerGasParameters<chain, chainOverride, type> | undefined,\n): Promise<EstimateFeesPerGasReturnType<type>> {\n  return internal_estimateFeesPerGas(client, args as any)\n}\n\nexport async function internal_estimateFeesPerGas<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined,\n  type extends FeeValuesType = 'eip1559',\n>(\n  client: Client<Transport, chain>,\n  args: EstimateFeesPerGasParameters<chain, chainOverride, type> & {\n    block?: Block | undefined\n    request?: PrepareTransactionRequestParameters<Chain, Account> | undefined\n  },\n): Promise<EstimateFeesPerGasReturnType<type>> {\n  const {\n    block: block_,\n    chain = client.chain,\n    request,\n    type = 'eip1559',\n  } = args || {}\n\n  const baseFeeMultiplier = await (async () => {\n    if (typeof chain?.fees?.baseFeeMultiplier === 'function')\n      return chain.fees.baseFeeMultiplier({\n        block: block_ as Block,\n        client,\n        request,\n      } as ChainFeesFnParameters)\n    return chain?.fees?.baseFeeMultiplier ?? 1.2\n  })()\n  if (baseFeeMultiplier < 1) throw new BaseFeeScalarError()\n\n  const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0\n  const denominator = 10 ** decimals\n  const multiply = (base: bigint) =>\n    (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /\n    BigInt(denominator)\n\n  const block = block_\n    ? block_\n    : await getAction(client, getBlock, 'getBlock')({})\n\n  if (typeof chain?.fees?.estimateFeesPerGas === 'function') {\n    const fees = (await chain.fees.estimateFeesPerGas({\n      block: block_ as Block,\n      client,\n      multiply,\n      request,\n      type,\n    } as ChainEstimateFeesPerGasFnParameters)) as unknown as EstimateFeesPerGasReturnType<type>\n\n    if (fees !== null) return fees\n  }\n\n  if (type === 'eip1559') {\n    if (typeof block.baseFeePerGas !== 'bigint')\n      throw new Eip1559FeesNotSupportedError()\n\n    const maxPriorityFeePerGas =\n      typeof request?.maxPriorityFeePerGas === 'bigint'\n        ? request.maxPriorityFeePerGas\n        : await internal_estimateMaxPriorityFeePerGas(\n            client as Client<Transport, Chain>,\n            {\n              block: block as Block,\n              chain,\n              request,\n            },\n          )\n\n    const baseFeePerGas = multiply(block.baseFeePerGas)\n    const maxFeePerGas =\n      request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas\n\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    } as EstimateFeesPerGasReturnType<type>\n  }\n\n  const gasPrice =\n    request?.gasPrice ??\n    multiply(await getAction(client, getGasPrice, 'getGasPrice')({}))\n  return {\n    gasPrice,\n  } as EstimateFeesPerGasReturnType<type>\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { EstimateGasParameters } from '../../actions/public/estimateGas.js'\nimport type { BaseError } from '../../errors/base.js'\nimport {\n  EstimateGasExecutionError,\n  type EstimateGasExecutionErrorType,\n} from '../../errors/estimateGas.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetEstimateGasErrorReturnType<cause = ErrorType> = Omit<\n  EstimateGasExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport function getEstimateGasError<err extends ErrorType<string>>(\n  err: err,\n  {\n    docsPath,\n    ...args\n  }: Omit<EstimateGasParameters, 'account'> & {\n    account?: Account | undefined\n    chain?: Chain | undefined\n    docsPath?: string | undefined\n  },\n): GetEstimateGasErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getNodeError(\n      err as {} as BaseError,\n      args as GetNodeErrorParameters,\n    )\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\n    return cause\n  })()\n  return new EstimateGasExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetEstimateGasErrorReturnType<err>\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetBalanceParameters = {\n  /** The address of the account. */\n  address: Address\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /** The balance of the account at a block tag. */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type GetBalanceReturnType = bigint\n\nexport type GetBalanceErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the balance of an address in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBalance\n * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)\n *\n * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).\n *\n * ```ts\n * const balance = await getBalance(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   blockTag: 'safe'\n * })\n * const balanceAsEther = formatEther(balance)\n * // \"6.942\"\n * ```\n *\n * @param client - Client to use\n * @param parameters - {@link GetBalanceParameters}\n * @returns The balance of the address in wei. {@link GetBalanceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBalance } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const balance = await getBalance(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n * // 10000000000000000000000n (wei)\n */\nexport async function getBalance<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { address, blockNumber, blockTag = 'latest' }: GetBalanceParameters,\n): Promise<GetBalanceReturnType> {\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n\n  const balance = await client.request({\n    method: 'eth_getBalance',\n    params: [address, blockNumberHex || blockTag],\n  })\n  return BigInt(balance)\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../../types/misc.js'\nimport {\n  type ConcatHexErrorType,\n  concatHex,\n} from '../../../utils/data/concat.js'\nimport {\n  type HexToBytesErrorType,\n  hexToBytes,\n} from '../../../utils/encoding/toBytes.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../../utils/encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../../../utils/encoding/toRlp.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../../utils/hash/keccak256.js'\nimport type { Authorization } from '../types/authorization.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashAuthorizationParameters<to extends To> = Authorization & {\n  /** Output format. @default \"hex\" */\n  to?: to | To | undefined\n}\n\nexport type HashAuthorizationReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashAuthorizationErrorType =\n  | Keccak256ErrorType\n  | ConcatHexErrorType\n  | ToRlpErrorType\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport function hashAuthorization<to extends To = 'hex'>(\n  parameters: HashAuthorizationParameters<to>,\n): HashAuthorizationReturnType<to> {\n  const { chainId, contractAddress, nonce, to } = parameters\n  const hash = keccak256(\n    concatHex([\n      '0x05',\n      toRlp([\n        numberToHex(chainId),\n        contractAddress,\n        nonce ? numberToHex(nonce) : '0x',\n      ]),\n    ]),\n  )\n  if (to === 'bytes') return hexToBytes(hash) as HashAuthorizationReturnType<to>\n  return hash as HashAuthorizationReturnType<to>\n}\n", "import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../../types/misc.js'\nimport type { OneOf } from '../../../types/utils.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from '../../../utils/signature/recoverAddress.js'\nimport type {\n  Authorization,\n  SignedAuthorization,\n} from '../types/authorization.js'\nimport {\n  type HashAuthorizationErrorType,\n  hashAuthorization,\n} from './hashAuthorization.js'\n\nexport type RecoverAuthorizationAddressParameters<\n  authorization extends OneOf<Authorization | SignedAuthorization> = OneOf<\n    Authorization | SignedAuthorization\n  >,\n  //\n  _signature = Hex | ByteArray | OneOf<Signature | SignedAuthorization>,\n> = {\n  /**\n   * The Authorization object.\n   *\n   * - If an unsigned `authorization` is provided, the `signature` property is required.\n   * - If a signed `authorization` is provided, the `signature` property does not need to be provided.\n   */\n  authorization: authorization | OneOf<Authorization | SignedAuthorization>\n} & (authorization extends SignedAuthorization\n  ? {\n      /** Signature of the Authorization. Not required if the `authorization` is signed. */\n      signature?: _signature | undefined\n    }\n  : {\n      /** Signature of the Authorization. Not required if the `authorization` is signed. */\n      signature: _signature\n    })\n\nexport type RecoverAuthorizationAddressReturnType = Address\n\nexport type RecoverAuthorizationAddressErrorType =\n  | HashAuthorizationErrorType\n  | RecoverAddressErrorType\n  | ErrorType\n\nexport async function recoverAuthorizationAddress<\n  const authorization extends OneOf<Authorization | SignedAuthorization>,\n>(\n  parameters: RecoverAuthorizationAddressParameters<authorization>,\n): Promise<RecoverAuthorizationAddressReturnType> {\n  const { authorization, signature } = parameters\n\n  return recoverAddress({\n    hash: hashAuthorization(authorization as Authorization),\n    signature: (signature ?? authorization) as Signature,\n  })\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToNumberErrorType,\n  hexToNumber,\n} from '../../utils/encoding/fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetTransactionCountParameters = {\n  /** The account address. */\n  address: Address\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag | undefined\n    }\n)\nexport type GetTransactionCountReturnType = number\n\nexport type GetTransactionCountErrorType =\n  | RequestErrorType\n  | NumberToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has sent.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionCount\n * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionCountParameters}\n * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionCount = await getTransactionCount(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function getTransactionCount<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  { address, blockTag = 'latest', blockNumber }: GetTransactionCountParameters,\n): Promise<GetTransactionCountReturnType> {\n  const count = await client.request(\n    {\n      method: 'eth_getTransactionCount',\n      params: [address, blockNumber ? numberToHex(blockNumber) : blockTag],\n    },\n    { dedupe: Boolean(blockNumber) },\n  )\n  return hexToNumber(count)\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  internal_estimateFeesPerGas,\n} from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  estimateGas,\n} from '../../actions/public/estimateGas.js'\nimport {\n  type GetBlockErrorType,\n  getBlock as getBlock_,\n} from '../../actions/public/getBlock.js'\nimport {\n  type GetTransactionCountErrorType,\n  getTransactionCount,\n} from '../../actions/public/getTransactionCount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { AccountNotFoundErrorType } from '../../errors/account.js'\nimport {\n  Eip1559FeesNotSupportedError,\n  MaxFeePerGasTooLowError,\n} from '../../errors/fee.js'\nimport type { DeriveAccount, GetAccountParameter } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { GetChainParameter } from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type {\n  TransactionRequest,\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestEIP7702,\n  TransactionRequestLegacy,\n  TransactionSerializable,\n} from '../../types/transaction.js'\nimport type {\n  ExactPartial,\n  IsNever,\n  Prettify,\n  UnionOmit,\n  UnionRequiredBy,\n} from '../../types/utils.js'\nimport { blobsToCommitments } from '../../utils/blob/blobsToCommitments.js'\nimport { blobsToProofs } from '../../utils/blob/blobsToProofs.js'\nimport { commitmentsToVersionedHashes } from '../../utils/blob/commitmentsToVersionedHashes.js'\nimport { toBlobSidecars } from '../../utils/blob/toBlobSidecars.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { NonceManager } from '../../utils/nonceManager.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport {\n  type GetTransactionType,\n  getTransactionType,\n} from '../../utils/transaction/getTransactionType.js'\nimport { getChainId as getChainId_ } from '../public/getChainId.js'\n\nexport const defaultParameters = [\n  'blobVersionedHashes',\n  'chainId',\n  'fees',\n  'gas',\n  'nonce',\n  'type',\n] as const\n\nexport type PrepareTransactionRequestParameterType =\n  | 'blobVersionedHashes'\n  | 'chainId'\n  | 'fees'\n  | 'gas'\n  | 'nonce'\n  | 'sidecars'\n  | 'type'\ntype ParameterTypeToParameters<\n  parameterType extends PrepareTransactionRequestParameterType,\n> = parameterType extends 'fees'\n  ? 'maxFeePerGas' | 'maxPriorityFeePerGas' | 'gasPrice'\n  : parameterType\n\nexport type PrepareTransactionRequestRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter & {\n    /**\n     * Nonce manager to use for the transaction request.\n     */\n    nonceManager?: NonceManager | undefined\n    /**\n     * Parameters to prepare for the transaction request.\n     *\n     * @default ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type']\n     */\n    parameters?: readonly PrepareTransactionRequestParameterType[] | undefined\n  }\n\nexport type PrepareTransactionRequestParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, accountOverride, false> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & { chainId?: number | undefined }\n\nexport type PrepareTransactionRequestReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n  ///\n  _derivedAccount extends Account | Address | undefined = DeriveAccount<\n    account,\n    accountOverride\n  >,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n  _transactionType = request['type'] extends string | undefined\n    ? request['type']\n    : GetTransactionType<request> extends 'legacy'\n      ? unknown\n      : GetTransactionType<request>,\n  _transactionRequest extends TransactionRequest =\n    | (_transactionType extends 'legacy' ? TransactionRequestLegacy : never)\n    | (_transactionType extends 'eip1559' ? TransactionRequestEIP1559 : never)\n    | (_transactionType extends 'eip2930' ? TransactionRequestEIP2930 : never)\n    | (_transactionType extends 'eip4844' ? TransactionRequestEIP4844 : never)\n    | (_transactionType extends 'eip7702' ? TransactionRequestEIP7702 : never),\n> = Prettify<\n  UnionRequiredBy<\n    Extract<\n      UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n        (_derivedChain extends Chain\n          ? { chain: _derivedChain }\n          : { chain?: undefined }) &\n        (_derivedAccount extends Account\n          ? { account: _derivedAccount; from: Address }\n          : { account?: undefined; from?: undefined }),\n      IsNever<_transactionRequest> extends true\n        ? unknown\n        : ExactPartial<_transactionRequest>\n    > & { chainId?: number | undefined },\n    ParameterTypeToParameters<\n      request['parameters'] extends readonly PrepareTransactionRequestParameterType[]\n        ? request['parameters'][number]\n        : (typeof defaultParameters)[number]\n    >\n  > &\n    (unknown extends request['kzg'] ? {} : Pick<request, 'kzg'>)\n>\n\nexport type PrepareTransactionRequestErrorType =\n  | AccountNotFoundErrorType\n  | AssertRequestErrorType\n  | ParseAccountErrorType\n  | GetBlockErrorType\n  | GetTransactionCountErrorType\n  | EstimateGasErrorType\n  | EstimateFeesPerGasErrorType\n\n/**\n * Prepares a transaction request for signing.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n *\n * @param args - {@link PrepareTransactionRequestParameters}\n * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function prepareTransactionRequest<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends PrepareTransactionRequestRequest<chain, chainOverride>,\n  accountOverride extends Account | Address | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: PrepareTransactionRequestParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride,\n    request\n  >,\n): Promise<\n  PrepareTransactionRequestReturnType<\n    chain,\n    account,\n    chainOverride,\n    accountOverride,\n    request\n  >\n> {\n  const {\n    account: account_ = client.account,\n    blobs,\n    chain,\n    gas,\n    kzg,\n    nonce,\n    nonceManager,\n    parameters = defaultParameters,\n    type,\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = { ...args, ...(account ? { from: account?.address } : {}) }\n\n  let block: Block | undefined\n  async function getBlock(): Promise<Block> {\n    if (block) return block\n    block = await getAction(\n      client,\n      getBlock_,\n      'getBlock',\n    )({ blockTag: 'latest' })\n    return block\n  }\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (chain) return chain.id\n    if (typeof args.chainId !== 'undefined') return args.chainId\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  if (\n    (parameters.includes('blobVersionedHashes') ||\n      parameters.includes('sidecars')) &&\n    blobs &&\n    kzg\n  ) {\n    const commitments = blobsToCommitments({ blobs, kzg })\n\n    if (parameters.includes('blobVersionedHashes')) {\n      const versionedHashes = commitmentsToVersionedHashes({\n        commitments,\n        to: 'hex',\n      })\n      request.blobVersionedHashes = versionedHashes\n    }\n    if (parameters.includes('sidecars')) {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      const sidecars = toBlobSidecars({\n        blobs,\n        commitments,\n        proofs,\n        to: 'hex',\n      })\n      request.sidecars = sidecars\n    }\n  }\n\n  if (parameters.includes('chainId')) request.chainId = await getChainId()\n\n  if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {\n    if (nonceManager) {\n      const chainId = await getChainId()\n      request.nonce = await nonceManager.consume({\n        address: account.address,\n        chainId,\n        client,\n      })\n    } else {\n      request.nonce = await getAction(\n        client,\n        getTransactionCount,\n        'getTransactionCount',\n      )({\n        address: account.address,\n        blockTag: 'pending',\n      })\n    }\n  }\n\n  if (\n    (parameters.includes('fees') || parameters.includes('type')) &&\n    typeof type === 'undefined'\n  ) {\n    try {\n      request.type = getTransactionType(\n        request as TransactionSerializable,\n      ) as any\n    } catch {\n      // infer type from block\n      const block = await getBlock()\n      request.type =\n        typeof block?.baseFeePerGas === 'bigint' ? 'eip1559' : 'legacy'\n    }\n  }\n\n  if (parameters.includes('fees')) {\n    // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.\n\n    if (request.type !== 'legacy' && request.type !== 'eip2930') {\n      // EIP-1559 fees\n      if (\n        typeof request.maxFeePerGas === 'undefined' ||\n        typeof request.maxPriorityFeePerGas === 'undefined'\n      ) {\n        const block = await getBlock()\n        const { maxFeePerGas, maxPriorityFeePerGas } =\n          await internal_estimateFeesPerGas(client, {\n            block: block as Block,\n            chain,\n            request: request as PrepareTransactionRequestParameters,\n          })\n\n        if (\n          typeof args.maxPriorityFeePerGas === 'undefined' &&\n          args.maxFeePerGas &&\n          args.maxFeePerGas < maxPriorityFeePerGas\n        )\n          throw new MaxFeePerGasTooLowError({\n            maxPriorityFeePerGas,\n          })\n\n        request.maxPriorityFeePerGas = maxPriorityFeePerGas\n        request.maxFeePerGas = maxFeePerGas\n      }\n    } else {\n      // Legacy fees\n      if (\n        typeof args.maxFeePerGas !== 'undefined' ||\n        typeof args.maxPriorityFeePerGas !== 'undefined'\n      )\n        throw new Eip1559FeesNotSupportedError()\n\n      const block = await getBlock()\n      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(\n        client,\n        {\n          block: block as Block,\n          chain,\n          request: request as PrepareTransactionRequestParameters,\n          type: 'legacy',\n        },\n      )\n      request.gasPrice = gasPrice_\n    }\n  }\n\n  if (parameters.includes('gas') && typeof gas === 'undefined')\n    request.gas = await getAction(\n      client,\n      estimateGas,\n      'estimateGas',\n    )({\n      ...request,\n      account: account\n        ? { address: account.address, type: 'json-rpc' }\n        : undefined,\n    } as EstimateGasParameters)\n\n  assertRequest(request as AssertRequestParameters)\n\n  delete request.parameters\n\n  return request as any\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../experimental/eip7702/utils/recoverAuthorizationAddress.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetEstimateGasErrorReturnType,\n  getEstimateGasError,\n} from '../../utils/errors/getEstimateGasError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { serializeStateOverride } from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport {\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../wallet/prepareTransactionRequest.js'\nimport { getBalance } from './getBalance.js'\n\nexport type EstimateGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedEstimateGas<chain>, 'from'> & {\n  account?: Account | Address | undefined\n  stateOverride?: StateOverride | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\ntype FormattedEstimateGas<chain extends Chain | undefined = Chain | undefined> =\n  FormattedTransactionRequest<chain>\n\nexport type EstimateGasReturnType = bigint\n\nexport type EstimateGasErrorType = GetEstimateGasErrorReturnType<\n  | ParseAccountErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | RecoverAuthorizationAddressErrorType\n  | AssertRequestErrorType\n>\n\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: EstimateGasParameters<chain>,\n): Promise<EstimateGasReturnType> {\n  const account_ = args.account ?? client.account\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    const {\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      blockNumber,\n      blockTag,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value,\n      stateOverride,\n      ...rest\n    } = (await prepareTransactionRequest(client, {\n      ...args,\n      parameters:\n        // Some RPC Providers do not compute versioned hashes from blobs. We will need\n        // to compute them.\n        account?.type === 'local' ? undefined : ['blobVersionedHashes'],\n    } as PrepareTransactionRequestParameters)) as EstimateGasParameters\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const rpcStateOverride = serializeStateOverride(stateOverride)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (rest.to) return rest.to\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    assertRequest(args as AssertRequestParameters)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format: chainFormat }),\n      from: account?.address,\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest)\n\n    function estimateGas_rpc(parameters: {\n      block: any\n      request: any\n      rpcStateOverride: any\n    }) {\n      const { block, request, rpcStateOverride } = parameters\n      return client.request({\n        method: 'eth_estimateGas',\n        params: rpcStateOverride\n          ? [request, block ?? 'latest', rpcStateOverride]\n          : block\n            ? [request, block]\n            : [request],\n      })\n    }\n\n    let estimate = BigInt(\n      await estimateGas_rpc({ block, request, rpcStateOverride }),\n    )\n\n    // TODO(7702): Remove this once https://github.com/ethereum/execution-apis/issues/561 is resolved.\n    //       Authorization list schema is not implemented on JSON-RPC spec yet, so we need to\n    //       manually estimate the gas.\n    if (authorizationList) {\n      const value = await getBalance(client, { address: request.from })\n      const estimates = await Promise.all(\n        authorizationList.map(async (authorization) => {\n          const { contractAddress } = authorization\n          const estimate = await estimateGas_rpc({\n            block,\n            request: {\n              authorizationList: undefined,\n              data,\n              from: account?.address,\n              to: contractAddress,\n              value: numberToHex(value),\n            },\n            rpcStateOverride,\n          }).catch(() => 100_000n)\n          return 2n * BigInt(estimate)\n        }),\n      )\n      estimate += estimates.reduce((acc, curr) => acc + curr, 0n)\n    }\n\n    return estimate\n  } catch (err) {\n    throw getEstimateGasError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n", "import { BaseError } from './base.js'\n\nexport type AccountNotFoundErrorType = AccountNotFoundError & {\n  name: 'AccountNotFoundError'\n}\nexport class AccountNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath?: string | undefined } = {}) {\n    super(\n      [\n        'Could not find an Account to execute with this Action.',\n        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',\n      ].join('\\n'),\n      {\n        docsPath,\n        docsSlug: 'account',\n        name: 'AccountNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AccountTypeNotSupportedErrorType = AccountTypeNotSupportedError & {\n  name: 'AccountTypeNotSupportedError'\n}\nexport class AccountTypeNotSupportedError extends BaseError {\n  constructor({\n    docsPath,\n    metaMessages,\n    type,\n  }: {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n    type: string\n  }) {\n    super(`Account type \"${type}\" is not supported.`, {\n      docsPath,\n      metaMessages,\n      name: 'AccountTypeNotSupportedError',\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": ["yParityOrV", "recoveryBit", "sha256", "sha256", "size", "size", "blobs", "commitments", "proofs", "v", "_a", "_b", "cause", "getBlock", "getChainId", "chainId", "block", "block", "request", "rpcStateOverride", "value", "estimate"]
}
